## أنواع البيانات في قواعد البيانات (SQL)
### ما هي أنواع البيانات؟

أنواع البيانات هي التصنيفات التي تحدد نوع المعلومات اللي ممكن نخزنها في كل عمود داخل جدول قاعدة البيانات. تحديد نوع البيانات مهم جدًا عشان قواعد البيانات تعرف تتعامل مع البيانات بشكل صحيح، سواء في التخزين أو العمليات أو الاستعلام.

---

## أشهر أنواع البيانات في SQL مع تفاصيلها:

### 1. **البيانات الرقمية الدقيقة (Exact Numeric Types)**

تستخدم لتخزين الأعداد الصحيحة أو الأعداد العشرية بدقة عالية.

| نوع البيانات | الوصف                            | الحجم (الذاكرة) | المجال (Range)                                  |
|--------------|---------------------------------|-----------------|------------------------------------------------|
| `BIGINT`     | عدد صحيح كبير جدًا              | 8 بايت          | من -9,223,372,036,854,775,808 إلى 9,223,372,036,854,775,807 |
| `INT`        | عدد صحيح متوسط                  | 4 بايت          | من -2,147,483,648 إلى 2,147,483,647            |
| `SMALLINT`   | عدد صحيح صغير                  | 2 بايت          | من -32,768 إلى 32,767                           |
| `TINYINT`    | عدد صحيح صغير جدًا              | 1 بايت          | من 0 إلى 255                                   |
| `DECIMAL(p,s)` أو `NUMERIC(p,s)` | أعداد عشرية بدقة محددة (p=الدقة، s=الجزء العشري) | يعتمد على الدقة | أرقام عشرية ثابتة الدقة                         |
| `MONEY`      | لتخزين القيم المالية           | 8 بايت          | من -922,337,203,685,477.5808 إلى 922,337,203,685,477.5807 |

---

### 2. **البيانات الرقمية التقريبية (Approximate Numeric Types)**

تخزن أعداد بفواصل عشرية لكن بدقة تقريبية.

| نوع البيانات | الوصف                       | الحجم (الذاكرة) |
|--------------|----------------------------|-----------------|
| `FLOAT`      | عدد عشري تقريبي            | 4 أو 8 بايت     |
| `REAL`       | عدد عشري تقريبي بدقة أقل   | 4 بايت          |
| `DOUBLE`     | عدد عشري بدقة عالية (في بعض الأنظمة) | 8 بايت          |

---

### 3. **أنواع البيانات النصية (Character Types)**

تخزن نصوص وأحرف.

| نوع البيانات | الوصف                               | الحجم (الذاكرة)              |
|--------------|------------------------------------|------------------------------|
| `CHAR(n)`    | نص ثابت الطول، طول n حرف          | n بايت                      |
| `VARCHAR(n)` | نص متغير الطول حتى n حرف           | طول النص + 2 بايت           |
| `TEXT`       | نص طويل جدًا                       | حتى 2 جيجابايت (حسب النظام) |

---

### 4. **أنواع بيانات التاريخ والوقت (Date and Time Types)**

لتخزين التواريخ والأوقات.

| نوع البيانات | الوصف                     | الشكل النموذجي             |
|--------------|--------------------------|----------------------------|
| `DATE`       | تاريخ فقط                | YYYY-MM-DD                 |
| `TIME`       | وقت فقط                  | HH:MM:SS                   |
| `DATETIME`   | تاريخ ووقت معًا          | YYYY-MM-DD HH:MM:SS        |
| `TIMESTAMP`  | تاريخ ووقت مع توقيت عالمي | YYYY-MM-DD HH:MM:SS + توقيت |

---

### 5. **أنواع بيانات منطقية (Boolean)**

- `BOOLEAN` أو `BIT`: تخزن قيم صحيحة أو خاطئة (True/False)، في بعض الأنظمة تخزن كـ 0 أو 1.

---

### 6. **أنواع البيانات الثنائية (Binary Types)**

لتخزين بيانات غير نصية مثل الصور أو الملفات.

| نوع البيانات | الوصف                          | الحجم (الذاكرة)               |
|--------------|-------------------------------|-------------------------------|
| `BINARY(n)`  | بيانات ثنائية ثابتة الطول n بايت | n بايت                      |
| `VARBINARY(n)` | بيانات ثنائية متغيرة الطول حتى n بايت | طول البيانات + 2 بايت     |
| `IMAGE`      | بيانات ثنائية كبيرة (صور، ملفات) | حتى 2 جيجابايت (حسب النظام) |

---

### 7. **أنواع بيانات أخرى متقدمة**

- `XML`: لتخزين بيانات بصيغة XML.  
- `UNIQUEIDENTIFIER`: لتخزين معرفات فريدة (GUID).  
- `SQL_VARIANT`: لتخزين قيم بأنواع بيانات مختلفة في نفس العمود.  
- `GEOGRAPHY` و `GEOMETRY`: لتخزين بيانات مكانية وجغرافية.

---

## أهمية تحديد نوع البيانات الصحيح

- **تحسين الأداء:** تحديد نوع مناسب يقلل استهلاك الذاكرة ويحسن سرعة الاستعلامات.  
- **سلامة البيانات:** يمنع إدخال بيانات غير صحيحة (مثلاً، رقم في عمود نص).  
- **سهولة المعالجة:** تسهل العمليات الحسابية، الترتيب، والبحث.

---

## مثال عملي :

لو عندك جدول للمرضى في عيادة:

| العمود          | نوع البيانات       | السبب                      |
|-----------------|--------------------|----------------------------|
| `patient_id`    | `INT`              | رقم المريض، عدد صحيح       |
| `name`          | `VARCHAR(50)`      | اسم المريض نص متغير الطول  |
| `birth_date`    | `DATE`             | تاريخ ميلاد المريض          |
| `weight`        | `DECIMAL(5,2)`     | وزن المريض بدقة عشرية      |
| `is_diabetic`   | `BOOLEAN`          | حالة السكري (نعم/لا)       |
| `profile_photo` | `VARBINARY(MAX)`   | صورة المريض (بيانات ثنائية) |



---
---
# شرح أنواع البيانات في SQL مع أهمية معرفة الحجم

**أنواع البيانات** في SQL هي التصنيفات اللي بتحدد نوع المعلومات اللي ممكن نخزنها في أعمدة جداول قاعدة البيانات، زي الأرقام، النصوص، أو التواريخ. تحديد نوع البيانات الصحيح مهم عشان نضمن سلامة البيانات، تحسين الأداء، وتوفير مساحة التخزين. الجزء ده هيشرح كل جدول من جداول أنواع البيانات المقدمة، مع توضيح ليه معرفة **حجم الذاكرة** لكل نوع مهم، باستخدام سياق قاعدة بيانات طبية.

---

## أنواع البيانات في SQL

### 1. البيانات الرقمية الدقيقة (Exact Numeric Types)

تُستخدم لتخزين الأعداد الصحيحة أو العشرية بدقة عالية، زي أرقام تعريف المرضى أو أوزانهم.

| نوع البيانات | الوصف                            | الحجم (الذاكرة) | المجال (Range)                                  |
|--------------|---------------------------------|-----------------|------------------------------------------------|
| `BIGINT`     | عدد صحيح كبير جدًا              | 8 بايت          | من -9,223,372,036,854,775,808 إلى 9,223,372,036,854,775,807 |
| `INT`        | عدد صحيح متوسط                  | 4 بايت          | من -2,147,483,648 إلى 2,147,483,647            |
| `SMALLINT`   | عدد صحيح صغير                  | 2 بايت          | من -32,768 إلى 32,767                           |
| `TINYINT`    | عدد صحيح صغير جدًا              | 1 بايت          | من 0 إلى 255                                   |
| `DECIMAL(p,s)` أو `NUMERIC(p,s)` | أعداد عشرية بدقة محددة (p=الدقة، s=الجزء العشري) | يعتمد على الدقة | أرقام عشرية ثابتة الدقة                         |
| `MONEY`      | لتخزين القيم المالية           | 8 بايت          | من -922,337,203,685,477.5808 إلى 922,337,203,685,477.5807 |

**شرح الجدول**:
- **الوصف**: 
  - `BIGINT`: مناسب لأرقام كبيرة جدًا، زي معرفات عالمية للمرضى في نظام مستشفيات دولي.
  - `INT`: الأكثر استخدامًا لأرقام تعريف متوسطة، زي `patient_id` في عيادة محلية.
  - `SMALLINT`: لأرقام صغيرة، زي عدد الأسرة في قسم بالمستشفى.
  - `TINYINT`: لأرقام محدودة، زي ترتيب غرفة (1 إلى 255).
  - `DECIMAL(p,s)`: للأعداد العشرية الدقيقة، زي وزن مريض (`DECIMAL(5,2)` لـ 123.45).
  - `MONEY`: لتخزين المبالغ المالية، زي تكلفة زيارة.
- **الحجم**: 
  - يتراوح من 1 بايت (`TINYINT`) إلى 8 بايت (`BIGINT`, `MONEY`)، بينما `DECIMAL` يعتمد على الدقة (مثل `DECIMAL(10,2)` يأخذ حوالي 5-17 بايت حسب النظام).
- **المجال**: يحدد النطاق اللي ينفع نخزن فيه أرقام، عشان نتجنب أخطاء التجاوز (Overflow).

**ليه مهم نعرف الحجم؟**:
- **توفير المساحة**: اختيار `TINYINT` (1 بايت) بدل `BIGINT` (8 بايت) لو الأرقام صغيرة (زي عدد الزيارات اليومية) بيقلل استهلاك الذاكرة، خصوصًا في قواعد بيانات كبيرة.
- **تحسين الأداء**: أنواع بيانات أصغر حجمًا تسرّع عمليات الاستعلام والفهرسة (Indexes).
- **تجنب الأخطاء**: لو استخدمنا `SMALLINT` لمعرف مريض في نظام كبير، ممكن يحصل تجاوز لو تجاوزنا 32,767 مريض، فمعرفة المجال بتحمينا.
- **التكلفة**: في السحابة (زي AWS أو Azure)، مساحة التخزين بتكلف فلوس، فاختيار الحجم المناسب بيوفر تكاليف.

---

### 2. البيانات الرقمية التقريبية (Approximate Numeric Types)

تُستخدم لتخزين أعداد عشرية بدقة تقريبية، زي القياسات العلمية.

| نوع البيانات | الوصف                       | الحجم (الذاكرة) |
|--------------|----------------------------|-----------------|
| `FLOAT`      | عدد عشري تقريبي            | 4 أو 8 بايت     |
| `REAL`       | عدد عشري تقريبي بدقة أقل   | 4 بايت          |
| `DOUBLE`     | عدد عشري بدقة عالية (في بعض الأنظمة) | 8 بايت          |

**شرح الجدول**:
- **الوصف**: 
  - `FLOAT`: مناسب للأعداد العشرية اللي الدقة فيها مش حرجة، زي قياسات درجة حرارة المريض (37.6).
  - `REAL`: مشابه لـ `FLOAT` لكن بدقة أقل، يُستخدم في قواعد بيانات زي PostgreSQL.
  - `DOUBLE`: يوفر دقة أعلى من `FLOAT`، يُستخدم في حسابات علمية دقيقة (نادر في السياق الطبي).
- **الحجم**: 
  - `FLOAT` و`DOUBLE` يمكن يأخذوا 4 أو 8 بايت حسب الدقة المطلوبة، بينما `REAL` دايمًا 4 بايت.

**ليه مهم نعرف الحجم؟**:
- **توازن الدقة والمساحة**: `FLOAT` (4 بايت) بيوفر مساحة مقارنة بـ `DOUBLE` (8 بايت)، لكن `DOUBLE` أدق. اختيار الحجم المناسب بيحقق توازن بين الأداء والدقة.
- **الأداء**: أنواع زي `REAL` أسرع في المعالجة لأنها أصغر، لكن ممكن تفقد دقة في الحسابات الكبيرة.
- **التوافق**: بعض الأنظمة (زي MySQL) بتعامل `FLOAT` و`DOUBLE` بشكل مختلف، فمعرفة الحجم بتساعد في تصميم قاعدة بيانات متوافقة.
- **التكلفة**: زي البيانات الدقيقة، الحجم الأصغر بيقلل تكاليف التخزين في الأنظمة السحابية.

---

### 3. أنواع البيانات النصية (Character Types)

تُستخدم لتخزين النصوص والأحرف، زي أسماء المرضى أو الملاحظات.

| نوع البيانات | الوصف                               | الحجم (الذاكرة)              |
|--------------|------------------------------------|------------------------------|
| `CHAR(n)`    | نص ثابت الطول، طول n حرف          | n بايت                      |
| `VARCHAR(n)` | نص متغير الطول حتى n حرف           | طول النص + 2 بايت           |
| `TEXT`       | نص طويل جدًا                       | حتى 2 جيجابايت (حسب النظام) |

**شرح الجدول**:
- **الوصف**: 
  - `CHAR(n)`: يخزن نصوص بطول ثابت، يعني لو حددت `CHAR(10)` وخزنت "أحمد"، هيملأ الباقي بمسافات. مناسب لأكواد ثابتة الطول زي رمز الجنس (`M` أو `F`).
  - `VARCHAR(n)`: يخزن نصوص متغيرة الطول، يعني لو خزنت "أحمد" في `VARCHAR(50)`، هيأخذ مساحة "أحمد" فقط (+2 بايت للإدارة). مثالي لأسماء المرضى.
  - `TEXT`: للنصوص الطويلة، زي ملاحظات الطبيب عن حالة المريض.
- **الحجم**: 
  - `CHAR(n)`: دايمًا n بايت، بغض النظر عن طول النص.
  - `VARCHAR(n)`: طول النص الفعلي + 2 بايت لتخزين المعلومات الإدارية.
  - `TEXT`: يدعم نصوص ضخمة، لكن الحجم يعتمد على النظام (مثل 2 جيجابايت في SQL Server).

**ليه مهم نعرف الحجم؟**:
- **إدارة المساحة**: `VARCHAR` أكثر كفاءة من `CHAR` لو النصوص متغيرة الطول (زي أسماء المرضى)، بينما `CHAR` أفضل للأكواد الثابتة.
- **سرعة المعالجة**: `CHAR` أسرع في الاسترجاع لأن الطول ثابت، لكن `VARCHAR` بيوفر مساحة. معرفة الحجم بتساعد نختار حسب الاحتياج.
- **تجنب الهدر**: لو استخدمنا `TEXT` لتخزين نصوص قصيرة، هنهدر مساحة، بينما `VARCHAR(50)` كافي لأسماء.
- **التكلفة**: النصوص الطويلة زي `TEXT` بتزيد تكاليف التخزين، خصوصًا لو القاعدة كبيرة.

---

### 4. أنواع بيانات التاريخ والوقت (Date and Time Types)

تُستخدم لتخزين التواريخ والأوقات، زي تواريخ زيارات المرضى.

| نوع البيانات | الوصف                     | الشكل النموذجي             |
|--------------|--------------------------|----------------------------|
| `DATE`       | تاريخ فقط                | YYYY-MM-DD                 |
| `TIME`       | وقت فقط                  | HH:MM:SS                   |
| `DATETIME`   | تاريخ ووقت معًا          | YYYY-MM-DD HH:MM:SS        |
| `TIMESTAMP`  | تاريخ ووقت مع توقيت عالمي | YYYY-MM-DD HH:MM:SS + توقيت |

**شرح الجدول**:
- **الوصف**: 
  - `DATE`: لتخزين تواريخ فقط، زي تاريخ ميلاد مريض (2025-06-09).
  - `TIME`: لتخزين أوقات فقط، زي وقت موعد (14:30:00).
  - `DATETIME`: لتخزين تاريخ ووقت معًا، زي وقت زيارة (2025-06-09 14:30:00).
  - `TIMESTAMP`: مشابه لـ `DATETIME` لكن بيخزن التوقيت العالمي (UTC)، مناسب لتسجيل أحداث زي وقت تشخيص.
- **الشكل النموذجي**: يوضح الصيغة القياسية لتخزين البيانات.
- **الحجم** (ملاحظة: الجدول ما ذكرش الحجم صراحةً، لكن هيختلف حسب النظام):
  - `DATE`: عادةً 3-4 بايت.
  - `TIME`: عادةً 3 بايت.
  - `DATETIME`: عادةً 8 بايت.
  - `TIMESTAMP`: عادةً 4-8 بايت مع التوقيت.

**ليه مهم نعرف الحجم؟**:
- **توفير المساحة**: `DATE` (3-4 بايت) أصغر من `DATETIME` (8 بايت)، فلو محتاج تاريخ فقط (زي تاريخ ميلاد)، استخدام `DATE` بيوفر مساحة.
- **الأداء**: أنواع زي `TIMESTAMP` (4 بايت في MySQL) أسرع في الفهرسة مقارنة بـ `DATETIME`، خصوصًا لتسجيل الأحداث.
- **التعامل مع التوقيت**: `TIMESTAMP` بيحتاج مساحة إضافية للتوقيت العالمي، فمعرفة الحجم بتساعد لو بنصمم نظام عالمي.
- **التكلفة**: التواريخ والأوقات الكثيرة في قاعدة بيانات كبيرة بتزيد التكلفة، فاختيار النوع الأصغر بيقلل المصاريف.

---

### 5. أنواع البيانات المنطقية (Boolean)

تُستخدم لتخزين قيم ثنائية (صحيح/خاطئ).

- `BOOLEAN` أو `BIT`: تخزن قيم `TRUE` أو `FALSE`، وفي بعض الأنظمة (زي MySQL) تُخزن كـ `0` أو `1`.

**شرح الجدول**:
- **الوصف**: 
  - `BOOLEAN`: مثالي لتخزين حالات ثنائية، زي إذا كان المريض مصاب بالسكري أو لا (`TRUE`/`FALSE`).
  - `BIT`: مشابه لـ `BOOLEAN` لكن يُستخدم في أنظمة زي SQL Server لتخزين 0 أو 1.
- **الحجم**: 
  - عادةً 1 بايت، لكن في بعض الأنظمة (زي SQL Server) ممكن يأخذ 1 بت لو مخزن مع بتات أخرى.

**ليه مهم نعرف الحجم؟**:
- **كفاءة التخزين**: `BOOLEAN` يأخذ مساحة صغيرة جدًا (1 بايت أو أقل)، فهو مثالي لأعمدة كتيرة بقيم ثنائية.
- **الأداء**: الحجم الصغير يسرّع الاستعلامات والفهرسة، خصوصًا في جداول كبيرة.
- **تصميم الجدول**: معرفة الحجم بتساعد نحدد إذا نقدر نستخدم `BIT` بدل `TINYINT` لو بنخزن 0/1 فقط.
- **التكلفة**: الحجم الصغير بيقلل تكاليف التخزين في قواعد البيانات السحابية.

---

### 6. أنواع البيانات الثنائية (Binary Types)

تُستخدم لتخزين بيانات غير نصية، زي الصور أو الملفات.

| نوع البيانات | الوصف                          | الحجم (الذاكرة)               |
|--------------|-------------------------------|-------------------------------|
| `BINARY(n)`  | بيانات ثنائية ثابتة الطول n بايت | n بايت                      |
| `VARBINARY(n)` | بيانات ثنائية متغيرة الطول حتى n بايت | طول البيانات + 2 بايت     |
| `IMAGE`      | بيانات ثنائية كبيرة (صور، ملفات) | حتى 2 جيجابايت (حسب النظام) |

**شرح الجدول**:
- **الوصف**: 
  - `BINARY(n)`: يخزن بيانات ثنائية بطول ثابت، زي مفتاح تشفير (16 بايت).
  - `VARBINARY(n)`: يخزن بيانات ثنائية متغيرة الطول، زي صورة صغيرة للمريض.
  - `IMAGE`: لتخزين ملفات كبيرة، زي أشعة المريض (ملاحظة: `IMAGE` عفا عليه الزمن في بعض الأنظمة زي SQL Server، ويُفضل `VARBINARY(MAX)`).
- **الحجم**: 
  - `BINARY(n)`: دايمًا n بايت.
  - `VARBINARY(n)`: طول البيانات الفعلي + 2 بايت للإدارة.
  - `IMAGE`: يدعم ملفات ضخمة تصل لـ 2 جيجابايت.

**ليه مهم نعرف الحجم؟**:
- **إدارة المساحة**: `VARBINARY` أكثر كفاءة من `BINARY` لو حجم البيانات متغير، بينما `IMAGE` بيأخذ مساحة كبيرة جدًا.
- **الأداء**: البيانات الثنائية الكبيرة بتبطئ الاستعلامات، فمعرفة الحجم بتساعد نختار نوع مناسب أو نخزن الملفات خارجيًا (زي تخزين الصور على خادم ملفات).
- **التكلفة**: البيانات الثنائية زي الصور بتكلف كتير في التخزين السحابي، فاختيار `VARBINARY` بدل `IMAGE` ممكن يوفر فلوس.
- **التوافق**: بعض الأنظمة بتفضل `VARBINARY(MAX)` على `IMAGE` للتوافق مع الإصدارات الحديثة.

---

### 7. أنواع البيانات الأخرى المتقدمة

تُستخدم في حالات متخصصة، زي تخزين بيانات جغرافية أو XML.

- `XML`: لتخزين بيانات بصيغة XML.
- `UNIQUEIDENTIFIER`: لتخزين معرفات فريدة (GUID).
- `SQL_VARIANT`: لتخزين قيم بأنواع بيانات مختلفة في نفس العمود.
- `GEOGRAPHY` و`GEOMETRY`: لتخزين بيانات مكانية وجغرافية.

**شرح القائمة**:
- **الوصف**: 
  - `XML`: يخزن بيانات مهيكلة، زي تقرير طبي بصيغة XML.
  - `UNIQUEIDENTIFIER`: يخزن معرفات فريدة عالميًا، زي معرف سجل طبي عبر أنظمة متعددة.
  - `SQL_VARIANT`: يسمح بتخزين أنواع بيانات مختلفة في عمود واحد (نادر الاستخدام في السياق الطبي).
  - `GEOGRAPHY`/`GEOMETRY`: لتخزين إحداثيات أو أشكال جغرافية، زي موقع عيادة.
- **الحجم**: 
  - `XML`: يعتمد على حجم البيانات (ممكن يوصل لجيجابايت).
  - `UNIQUEIDENTIFIER`: 16 بايت.
  - `SQL_VARIANT`: يعتمد على نوع البيانات المخزنة.
  - `GEOGRAPHY`/`GEOMETRY`: يعتمد على تعقيد البيانات.

**ليه مهم نعرف الحجم؟**:
- **إدارة الموارد**: أنواع زي `XML` و`GEOGRAPHY` بتأخذ مساحة كبيرة، فمعرفة الحجم بتساعد في تخطيط التخزين.
- **الأداء**: `UNIQUEIDENTIFIER` (16 بايت) أبطأ من `INT` (4 بايت) في الفهرسة، فمعرفة الحجم بتساعد نختار البديل المناسب.
- **التكلفة**: الأنواع المتقدمة بتزيد تكاليف التخزين، خصوصًا لو بنستخدمها بشكل غير ضروري.
- **التخصص**: معرفة الحجم بتساعد نحدد إذا كنا محتاجين نوع متقدم زي `GEOGRAPHY` أو نقدر نستخدم حلول أبسط.

---

## أهمية تحديد نوع البيانات الصحيح
- **تحسين الأداء**: أنواع البيانات الصغيرة تسرّع الاستعلامات والفهرسة.
- **سلامة البيانات**: تحديد النوع الصحيح يمنع إدخال بيانات غير صحيحة (مثل نص في عمود رقمي).
- **توفير المساحة**: اختيار أنواع مناسبة يقلل استهلاك الذاكرة وتكاليف التخزين.
- **سهولة الصيانة**: قاعدة بيانات منظمة بأنواع بيانات واضحة بتسهل التعديل والتوسع.

---

## مثال تطبيقي
جدول `patients` في عيادة:

```sql
CREATE TABLE patients (
    patient_id INT,
    name VARCHAR(50),
    birth_date DATE,
    weight DECIMAL(5,2),
    is_diabetic BOOLEAN,
    profile_photo VARBINARY(MAX)
);
```